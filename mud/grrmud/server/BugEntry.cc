//
//ScryMUD Server Code
//Copyright (C) 1998  Ben Greear
//
//This program is free software; you can redistribute it and/or
//modify it under the terms of the GNU General Public License
//as published by the Free Software Foundation; either version 2
//of the License, or (at your option) any later version.
//
//This program is distributed in the hope that it will be useful,
//but WITHOUT ANY WARRANTY; without even the implied warranty of
//MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//GNU General Public License for more details.
//
//You should have received a copy of the GNU General Public License
//along with this program; if not, write to the Free Software
//Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
//
// To contact the Author, Ben Greear:  greear@cyberhighway.net, (preferred)
//                                     greearb@agcs.com
//

#include "BugEntry.h"
#include "critter.h"
#include "misc2.h"

int BugEntry::_cnt = 0;
int BugCollection::_cnt = 0;

void BugEntry::appendNote(const String& note) {
   report += "\n<P>\n";
   report += note;
}

int BugEntry::read(ifstream& dafile) {
   char buf[100];
   dafile >> bug_num;

   // Terminator reached.
   if (bug_num == -1) {
      return -1;
   }

   dafile >> room_num;
   dafile.getline(buf, 99);

   dafile >> reporter;
   dafile.getline(buf, 99);

   dafile.getline(buf, 99);
   date = buf;
   date.Strip();

   report.Termed_Read(dafile);
   report.Strip(); //get rid of any extraneous white-space
   return bug_num;
}

int BugEntry::write(ofstream& dafile) {
   dafile << bug_num << " " << room_num << " bug_num, room_num\n";
   dafile << reporter << endl;
   dafile << date << endl;
   dafile << report << "\n~\n";
   
   return (dafile && 1);
};   


int BugEntry::writeHtml(ofstream& dafile) {
   String buf(report.Strlen() + 70);
   Sprintf(buf, "<li><pre>[%i] %P08<u>%S</u>  %P35By -:%S:- %P60in Room: %i\n</pre>%S\n</li>",
           bug_num, &date, &reporter, room_num, &report);

   dafile << buf << endl;
   
   return (dafile && 1);
};   

String BugEntry::toString() {
   String buf(report.Strlen() + 70);
   Sprintf(buf, "[%i] %P08%S:  %P35By -:%S:- %P60in Room: %i\n\t%S\n",
           bug_num, &date, &reporter, room_num, &report);
   return buf;
}




int BugCollection::write() {
   ofstream dafile(file_name);

   if (dafile) {
      dafile << next_bug_num << endl;

      Cell<BugEntry*> cll(bugs);
      BugEntry* ptr;
      while ((ptr = cll.next())) {
         ptr->write(dafile);
         dafile << endl;
      }//while

      dafile << -1 << "End of Bug Collection" << endl;
      return 0;
   }
   else {
      mudlog << "ERROR:  could not open BugCollection for writing, file -:"
             << file_name << endl;
      return -1;
   }
}//write


int BugCollection::writeHtml() {
   String tmp_name(file_name);
   tmp_name += ".html";

   ofstream dafile(tmp_name);

   if (dafile) {
      dafile << "
<HTML>
<HEAD> 
   <TITLE>  " << coll_name << " </TITLE>
</HEAD>
<BODY TEXT=\"#33DDFF\" BGCOLOR=\"#000000\" LINK=\"#FFD700\"
      VLINK=\"#DAA520\" ALINK=\"#FF0000\">

<CENTER>
<H2>
<FONT COLOR=\"#FFCC00\">ScryMUD " << coll_name << "</FONT></H2></CENTER>
This is an automagically generated list of <b>" << coll_name << "</b> entries
from ScryMUD.<P>";

      dafile << "<ol>\n";

      Cell<BugEntry*> cll(bugs);
      BugEntry* ptr;
      while ((ptr = cll.next())) {
         ptr->writeHtml(dafile);
         dafile << "<P>" << endl;
      }//while

      dafile << "</ol>
<ADDRESS>
Generated by:<A HREF=\"mailto:greear@cyberhighway.net\">Grock</A>
</ADDRESS></body></html>\n";
      return 0;
   }
   else {
      mudlog << "ERROR:  could not open BugCollection html file -:"
             << tmp_name << endl;
      return -1;
   }
}//writeHtml


int BugCollection::read() {
   char buf[100];
   ifstream dafile(file_name);
   int cnt = 0;

   if (dafile) {
      dafile >> next_bug_num;
      dafile.getline(buf, 99);

      BugEntry be;

      while (dafile && (be.read(dafile) != -1)) {
         cnt++;
         bugs.append(new BugEntry(be));
      }
      return cnt;
   }//if
   else {
      return -1;
   }
}//read
   
      
int BugCollection::removeBug(int num, const String& name, const String& notes,
                             BugCollection& completed_bc) {
   Cell<BugEntry*> cll(bugs);
   BugEntry* ptr;
   while ((ptr = cll.next())) {
      if ((ptr->getBugNum() == num) && 
          (strncasecmp(name, ptr->getReport(), max(name.Strlen(), 5)) == 0) ||
          (strcasecmp(name, ptr->getReport()) == 0)) {
         bugs.lose(cll);
         this->write();
         this->writeHtml();

         ptr->appendNote(notes);
         completed_bc.addBug(ptr);
         return 0;
      }
   }
   return -1;
}

int BugCollection::addBug(BugEntry* be) {
   if (be) {
      bugs.append(be);
      this->write();
      this->writeHtml();
      return 0;
   }
   return -1;
}

int BugCollection::addBug(const char* cur_date, int rnum, const String& reporter,
                          const String& report) {
   bugs.append(new BugEntry(next_bug_num, reporter, cur_date, report, rnum));
   next_bug_num++;

   this->write();
   this->writeHtml();
   return 0;
}


String BugCollection::toString() {
   String buf(10000);

   Cell<BugEntry*> cll(bugs);
   BugEntry* ptr;
   while ((ptr = cll.next())) {
      buf.Append(ptr->toString());
      buf.Append("\n");
   }
   return buf;
}
